
#Approach 1
def doubleL(n):
    res = []
    for i in range(n): res.append(i * 2)
    return res

for i in doubleL(5): 
    print(i, end=' : ')


The for loop iterates over the list generated by doubleL(5). 
Inside of doubleL(5), a list res is declared. Then, a for loop
iterates from i = 0 to i = n - 1 (which is 4). For each iteration,
i*2 is appended. So first i = 0, and 0*2 is 0, so 0 is appended.
i = 1 for second iteration, 1*2 is 2, so 2 is appended, and so on
until the 4th iteration where 8 is appended to the list. This
list is then passed to the for loop outside of the function which
iterates over every value in the list. For each value, it prints that value
and a colon after it.

#Approach 2
for x in [n * 2 for n in range(5)]:
    print(x, end=' : ')

Inside the square brackets, this is a list comprehension that generates a list of values 
based on n. From n = 0 to n = 4, n*2 is put into the list. Then, outside the list comprehension,
for each value inside the list, print that value and then a colon after it.



#Approach 3
def doubleG(n):
        for i in range(n):
            yield i * 2

for i in doubleG(5):
        print(i, end=' : ')

doubleG(n) is a generator function, which means it lazily generates a list of values. It requires more
space and memory than if it was implemented with a regular function, but it makes writing the code
much simpler and more intuitive.
